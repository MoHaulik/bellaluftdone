<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Enhanced WebXR Box Breathing App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
    }
    
    #start-button {
      width: 100%;
      height: 100vh;
      font-size: 120px;
      background: linear-gradient(135deg, rgba(72, 118, 255, 0.8), rgba(100, 80, 255, 0.9));
      color: white;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 50px rgba(72, 118, 255, 0.3);
    }
    
    #start-button:hover {
      background: linear-gradient(135deg, rgba(72, 118, 255, 0.9), rgba(100, 80, 255, 1.0));
      box-shadow: 0 0 80px rgba(72, 118, 255, 0.5);
    }

    .webxr-hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <button id="start-button">üå¨Ô∏è</button>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';

    /* ---------- globals ---------- */
    let camera, scene, renderer;
    let analyser, dataArray;
    let particles, particleMaterial;
    let glowMesh;
    let glowMaterial;
    let controllers = [];
    let xrSession = null;
    const clock = new THREE.Clock();
    let lastIntensity = 0;
    let sessionStartTime = 0;
    let backgroundAudio, introAudio, musicAudio;
    let isSessionEnding = false;
    let breathingStarted = false;
    let musicFadeStarted = false;

    /* ---------- breathing constants ---------- */
    const sessionDuration = 300; // 5 minutes
    const boxTiming = 4; // 4-4-4-4 seconds
    const cycleDuration = boxTiming * 4; // inhale + hold + exhale + hold

    /* ---------- particle constants ---------- */
    let currentParticleCount = 5; // Start with only 5 particles
    const maxParticleCount = 200; // Maximum particles
    const particleRadius = 3; // Reduced radius to keep particles more in front of user
    const particleSystem = { hueRange:[190, 260], baseSaturation: 0.7, baseSize: 0.3 };

    // Clap to exit variables
    let clapStartTime = 0;
    let isClapDetected = false;
    const CLAP_HOLD_DURATION = 2000;
    const CLAP_DISTANCE_THRESHOLD = 0.15;

    init();

    /* ======================================================================= */
    function init(){
      scene   = new THREE.Scene();
      camera  = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);
      renderer= new THREE.WebGLRenderer({antialias: true, alpha: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x404040, 1.5));
      const dl = new THREE.DirectionalLight(0xffffff, 1); 
      dl.position.set(1, 1, 1); 
      scene.add(dl);

      document.getElementById('start-button').addEventListener('click', startXR);
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    /* ======================  Start XR  (click handler) ====================== */
    async function startXR(){
      /* 1. unlock & play the background audio *before* any await */
      if(!backgroundAudio){
        backgroundAudio = new Audio('background.mp3');
        backgroundAudio.loop   = true;
        backgroundAudio.volume = 0.5;
        try{ await backgroundAudio.play(); }catch(e){ console.warn(e); }
      }

      /* 2. prepare intro audio */
      if(!introAudio){
        introAudio = new Audio('intro.mp4'); // or intro.mp3
        introAudio.volume = 0.8;
      }

      /* 3. prepare music audio for later fade-in */
      if(!musicAudio){
        musicAudio = new Audio('music.mp3');
        musicAudio.loop = true;
        musicAudio.volume = 0;
      }

      /* 4. request XR session */
      if(!navigator.xr){ alert('WebXR not supported'); return; }
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if(!supported){ alert('AR session not supported'); return; }

      const session = await navigator.xr.requestSession('immersive-ar',{
        optionalFeatures: ['dom-overlay', 'light-estimation'],
        domOverlay: { root: document.body }
      });

      /* 5. Safari/visionOS workaround: replay once camera is granted */
      session.addEventListener('visibilitychange', () => {
        backgroundAudio.play().catch(() => {});
        if (musicAudio && musicFadeStarted) {
          musicAudio.play().catch(() => {});
        }
      });
      
      // Handle session ending gracefully
      session.addEventListener('end', onSessionEnd);

      onSessionStarted(session);
    }

    /* ==========================  onSessionStarted  ========================= */
    function onSessionStarted(session){
      xrSession = session;
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);

      document.getElementById('start-button').classList.add('webxr-hidden');

      // Setup controllers for clap to exit
      setupControllers();

      // Start breathing exercise immediately
      breathingStarted = true;
      sessionStartTime = clock.getElapsedTime();

      renderer.setAnimationLoop(render);

      /* --- microphone for particle intensity --- */
      navigator.mediaDevices.getUserMedia({audio: true, video: false}).then(stream => {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const src = ctx.createMediaStreamSource(stream);
        analyser = ctx.createAnalyser(); 
        analyser.fftSize = 256; 
        analyser.smoothingTimeConstant = 0.6;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        src.connect(analyser);
      });

      createParticles();
      createEnhancedGlow();

      // Play intro audio
      if (introAudio) {
        introAudio.play().catch(e => console.warn('Intro audio play failed:', e));
      }
    }

    function setupControllers() {
      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        scene.add(controller);
        controllers.push(controller);
      }
    }

    function checkClapToExit() {
      if (!xrSession || controllers.length < 2) return;
      
      const controller1 = controllers[0];
      const controller2 = controllers[1];
      
      if (!controller1.visible || !controller2.visible) {
        isClapDetected = false;
        clapStartTime = 0;
        return;
      }
      
      const distance = controller1.position.distanceTo(controller2.position);
      
      if (distance <= CLAP_DISTANCE_THRESHOLD) {
        if (!isClapDetected) {
          isClapDetected = true;
          clapStartTime = Date.now();
        } else {
          const holdDuration = Date.now() - clapStartTime;
          if (holdDuration >= CLAP_HOLD_DURATION) {
            endSession();
            return;
          }
        }
      } else {
        isClapDetected = false;
        clapStartTime = 0;
      }
    }

    /* ===================  Visual objects  =================== */
    function createEnhancedGlow(){      
      // Create enhanced inner glow
      const glowGeometry = new THREE.CircleGeometry(1.2, 64);
      glowMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color: { value: new THREE.Color(0xffffff) },
          intensity: { value: 0.8 }  // Increased intensity
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color;
          uniform float intensity;
          varying vec2 vUv;
          
          void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = length(vUv - center) * 2.0;
            float alpha = smoothstep(1.0, 0.0, dist) * intensity;
            float pulse = 0.5 + 0.5 * sin(time * 2.0);
            alpha *= (0.7 + 0.5 * pulse);  // Enhanced pulse effect
            
            // Add some subtle color variation
            vec3 finalColor = color;
            finalColor += vec3(0.05 * sin(time + vUv.x * 3.0), 
                              0.05 * sin(time * 1.2 + vUv.y * 3.0), 
                              0.1 * sin(time * 0.8 + dist * 5.0));
            
            gl_FragColor = vec4(finalColor, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide
      });
      
      glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
      glowMesh.position.set(0, 0, -3);
      scene.add(glowMesh);
    }

    function createParticles(){
      const geo = new THREE.BufferGeometry();
      const pos = [], col = [], siz = [], alp = [], turb = [], mult = [];
      
      // Create particles positioned more toward the front of the user's view
      for(let i = 0; i < maxParticleCount; i++){
        const t = Math.random() * Math.PI * 2;
        const p = Math.acos(2 * Math.random() - 1);
        
        // Adjust radius distribution to keep particles closer to center and in front
        const r = Math.pow(Math.random(), 1.2) * particleRadius; // More concentrated toward center
        
        // Bias particles to be more in front of user
        const x = r * Math.sin(p) * Math.cos(t) * 0.7; // Reduce spread on X axis
        const y = r * Math.sin(p) * Math.sin(t) * 0.7; // Reduce spread on Y axis  
        const z = r * Math.cos(p) * 0.8 - 2; // Keep more in front, closer to breathing sphere
        pos.push(x, y, z);

        const c = new THREE.Color();
        const h = particleSystem.hueRange[0] + Math.random() * (particleSystem.hueRange[1] - particleSystem.hueRange[0]);
        const s = particleSystem.baseSaturation + Math.random() * 0.3, l = 0.5 + Math.random() * 0.5;
        c.setHSL(h / 360, s, l); col.push(c.r, c.g, c.b);

        siz.push(particleSystem.baseSize * (0.5 + Math.random()));
        mult.push(0.8 + Math.random() * 1.5);
        alp.push(0.2 + Math.random() * 0.8);
        turb.push(Math.random() * 2);
      }
      
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
      geo.setAttribute('customColor', new THREE.Float32BufferAttribute(col, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(siz, 1));
      geo.setAttribute('alpha', new THREE.Float32BufferAttribute(alp, 1));
      geo.setAttribute('turbulence', new THREE.Float32BufferAttribute(turb, 1));
      geo.setAttribute('sizeMultiplier', new THREE.Float32BufferAttribute(mult, 1));

      particleMaterial = new THREE.ShaderMaterial({
        uniforms: { 
          pointTexture: { value: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') },
          time: { value: 0 }, 
          breathFactor: { value: 0 }, 
          intensityFactor: { value: 0 },
          particleCount: { value: currentParticleCount } // Add particle count uniform
        },
        vertexShader: `
          attribute float size;
          attribute vec3 customColor;
          attribute float alpha;
          attribute float turbulence;
          attribute float sizeMultiplier;
          varying vec3 vColor;
          varying float vAlpha;
          uniform float time;
          uniform float breathFactor;
          uniform float intensityFactor;
          uniform float particleCount;
          
          void main() {
            // Only render particles up to current count
            if (float(gl_VertexID) >= particleCount) {
              gl_Position = vec4(0.0, 0.0, -100.0, 1.0); // Hide excess particles
              gl_PointSize = 0.0;
              vAlpha = 0.0;
              return;
            }
            
            vColor = customColor;
            
            vec3 p = position;
            float d = length(position.xy);
            
            // Box breathing: particles move toward camera (inhale) or away (exhale)
            // breathFactor: 1 = fully inhaled, 0 = fully exhaled, 0.5 = hold
            float movementFactor = (breathFactor - 0.5) * 2.0; // Convert 0-1 to -1 to 1
            
            // Calculate direction from particle to camera (always toward user)
            vec3 toCameraDir = normalize(-position); // Direction toward camera/user
            p += toCameraDir * movementFactor * (1.0 - d / 5.0) * 1.5;
            
            // Scale particles with breath (only during active breathing, not holds)
            if (abs(movementFactor) > 0.1) { // Only scale during active breathing
              float scaleFactor = abs(movementFactor) * 0.3;
              p.x += position.x * scaleFactor;
              p.y += position.y * scaleFactor;
            }
            
            // Enhanced turbulence
            float tAmt = turbulence * 0.4;
            p.x += sin(time * (0.5 + turbulence) + position.z * 2.0) * tAmt;
            p.y += cos(time * (0.7 + turbulence) + position.x * 2.0) * tAmt;
            p.z += sin(time * (0.9 + turbulence) + position.y * 2.0) * tAmt * 0.5;
            
            // Enhanced inner particle movement
            if(d < 3.0) {
              p.z += intensityFactor * sin(time * 2.0 + d * 3.0) * (3.0 - d) * 0.5;
            }
            
            vAlpha = alpha * (1.0 - length(position) / 5.0) * (0.6 + 0.4 * intensityFactor);
            float dyn = size * (1.0 + intensityFactor * 4.0 * sizeMultiplier);
            vec4 mv = modelViewMatrix * vec4(p, 1.0);
            gl_PointSize = dyn * (300.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform sampler2D pointTexture;
          varying vec3 vColor;
          varying float vAlpha;
          
          void main() {
            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            gl_FragColor = vec4(vColor, vAlpha * tex.a);
            if(gl_FragColor.a < 0.05) discard;
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(geo, particleMaterial);
      particles.position.set(0, 0, -3);
      scene.add(particles);
    }

    /* Function to gracefully end the session */
    function endSession() {
      if (xrSession) {
        xrSession.end();
      }
    }

    function onSessionEnd() {
      isSessionEnding = false;
      breathingStarted = false;
      musicFadeStarted = false;
      xrSession = null;
      
      document.getElementById('start-button').classList.remove('webxr-hidden');
      
      // Stop audio
      if (backgroundAudio) {
        backgroundAudio.pause();
        backgroundAudio.currentTime = 0;
      }
      
      if (musicAudio) {
        musicAudio.pause();
        musicAudio.currentTime = 0;
        musicAudio.volume = 0;
      }
      
      // Reset animation loop
      renderer.setAnimationLoop(null);
    }

    /* =========================  Render loop  ========================= */
    function render(){
      const delta = clock.getDelta();
      const now = clock.getElapsedTime();

      /* Don't process breathing if not started */
      if (!breathingStarted) {
        renderer.render(scene, camera);
        return;
      }

      // Check clap to exit
      checkClapToExit();

      const elapsed = now - sessionStartTime;

      /* Start music fade-in after 20 seconds */
      if (elapsed >= 20 && !musicFadeStarted && musicAudio) {
        musicFadeStarted = true;
        musicAudio.play().catch(e => console.warn('Music audio play failed:', e));
      }

      /* Fade in music gradually */
      if (musicFadeStarted && musicAudio && elapsed >= 20) {
        const fadeProgress = Math.min((elapsed - 20) / 10, 1); // 10 second fade-in
        musicAudio.volume = 0.4 * fadeProgress; // Target volume 0.4
      }

      /* mic intensity (0-1) -------------------------------------------------- */
      let micIntensity = 0;
      if(analyser){
        analyser.getByteFrequencyData(dataArray);
        let s = 0;
        for(let i = 2; i < 20; i++) s += dataArray[i] * 1.5;
        micIntensity = Math.pow(Math.min(1, (s / 18) / 128), 0.7);
      }

      /* stop when time is up ------------------------------------------------- */
      if(elapsed >= sessionDuration && !isSessionEnding){
        endSession();
        return;
      }

      /* box breathing cycle -------------------------------------------------- */
      const t = elapsed % cycleDuration;
      let stage, breathOffset;
      
      if(t < boxTiming) { 
        // Inhale phase
        stage = 'inhale'; 
        breathOffset = t / boxTiming; // 0 to 1
      }
      else if(t < boxTiming * 2) { 
        // Hold after inhale
        stage = 'inhale-hold'; 
        breathOffset = 1; // Stay at fully inhaled
      }
      else if(t < boxTiming * 3) {
        // Exhale phase
        stage = 'exhale';
        breathOffset = 1 - (t - boxTiming * 2) / boxTiming; // 1 to 0
      } else { 
        // Hold after exhale
        stage = 'exhale-hold'; 
        breathOffset = 0; // Stay at fully exhaled
      }

      /* update shaders -------------------------------------------------- */
      lastIntensity = lastIntensity * 0.7 + micIntensity * 0.3;
      particleMaterial.uniforms.time.value = now;
      particleMaterial.uniforms.breathFactor.value = breathOffset;
      particleMaterial.uniforms.intensityFactor.value = lastIntensity;

      // Conservative particle count progression - particles appear mainly during exhale
      // Hit 200 particles at 4:30 (270 seconds)
      const targetTime = 270; // 4 minutes 30 seconds
      let targetCount = 5;
      
      if (elapsed > 0) {
        // Base progression (very slow)
        const baseProgress = Math.min(elapsed / targetTime, 1);
        let baseCount = 5 + (195 * Math.pow(baseProgress, 2)); // Quadratic growth
        
        // Bonus particles during exhale phase
        if (stage === 'exhale') {
          const exhaleBonus = (1 - breathOffset) * 10; // Up to 10 extra during exhale
          baseCount += exhaleBonus;
        }
        
        targetCount = Math.min(Math.floor(baseCount), maxParticleCount);
      }
      
      // Smooth transition to target count
      currentParticleCount = Math.floor(currentParticleCount * 0.95 + targetCount * 0.05);
      particleMaterial.uniforms.particleCount.value = currentParticleCount;

      // Update glow material
      glowMaterial.uniforms.time.value = now;
      
      // Glow intensity and scale based on breathing stage
      let glowIntensity, glowScale;
      if (stage === 'inhale') {
        glowIntensity = 0.5 + 0.4 * breathOffset;
        glowScale = 1 + 0.3 * breathOffset;
      } else if (stage === 'inhale-hold') {
        glowIntensity = 0.9;
        glowScale = 1.3;
      } else if (stage === 'exhale') {
        glowIntensity = 0.9 - 0.4 * (1 - breathOffset);
        glowScale = 1.3 - 0.3 * (1 - breathOffset);
      } else { // exhale-hold
        glowIntensity = 0.5;
        glowScale = 1.0;
      }
      
      glowMaterial.uniforms.intensity.value = glowIntensity;
      glowMesh.scale.set(glowScale, glowScale, 1);
      
      // Set colors based on stage with enhanced color palette
      if (stage === 'inhale') {
        glowMaterial.uniforms.color.value.setStyle('#a3ddff'); // Light blue for inhale
      } else if (stage === 'inhale-hold') {
        glowMaterial.uniforms.color.value.setStyle('#c4f0ff'); // Brighter blue for hold
      } else if (stage === 'exhale') {
        glowMaterial.uniforms.color.value.setStyle('#d1e8ff'); // Pale blue for exhale
      } else {
        glowMaterial.uniforms.color.value.setStyle('#d8f0ff'); // Very pale blue for rest
      }

      // Rotate particle cloud with gentle, calming motion
      particles.rotation.z += 0.008 * delta;
      particles.rotation.y += 0.004 * delta;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
